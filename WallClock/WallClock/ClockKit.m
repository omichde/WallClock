//
//  ClockKit.m
//  WallClock
//
//  Created by Oliver on 02.01.17.
//  Copyright Â© 2017 CompanyName. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

#import "ClockKit.h"


@implementation ClockKit

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawNormalClockWithSecondValue: (CGFloat)secondValue minuteValue: (CGFloat)minuteValue hourValue: (CGFloat)hourValue
{
    [ClockKit drawNormalClockWithFrame: CGRectMake(0, 0, 500, 500) resizing: ClockKitResizingBehaviorStretch secondValue: secondValue minuteValue: minuteValue hourValue: hourValue];
}

+ (void)drawNormalClockWithFrame: (CGRect)targetFrame resizing: (ClockKitResizingBehavior)resizing secondValue: (CGFloat)secondValue minuteValue: (CGFloat)minuteValue hourValue: (CGFloat)hourValue
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Resize to Target Frame
    CGContextSaveGState(context);
    CGRect resizedFrame = ClockKitResizingBehaviorApply(resizing, CGRectMake(0, 0, 500, 500), targetFrame);
    CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
    CGContextScaleCTM(context, resizedFrame.size.width / 500, resizedFrame.size.height / 500);


    //// Color Declarations
    UIColor* hourColor = [UIColor colorWithRed: 0.198 green: 0.198 blue: 0.198 alpha: 1];
    UIColor* minuteColor = [UIColor colorWithRed: 0.472 green: 0.472 blue: 0.472 alpha: 1];
    UIColor* secondColor = [UIColor colorWithRed: 1 green: 0 blue: 0 alpha: 1];
    UIColor* outerColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 0.392];

    //// Variable Declarations
    CGFloat secondCalc = -secondValue * 6;
    CGFloat minuteCalc = -minuteValue * 6;
    CGFloat hourCalc = -hourValue * 30;

    //// hourPin Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 250, 250);
    CGContextRotateCTM(context, -hourCalc * M_PI/180);

    UIBezierPath* hourPinPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-7, -170, 14, 177) cornerRadius: 5];
    [hourColor setFill];
    [hourPinPath fill];
    [outerColor setStroke];
    hourPinPath.lineWidth = 0.5;
    [hourPinPath stroke];

    CGContextRestoreGState(context);


    //// minutePin Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 250, 250);
    CGContextRotateCTM(context, -minuteCalc * M_PI/180);

    UIBezierPath* minutePinPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-3, -250, 6, 253) cornerRadius: 3];
    [minuteColor setFill];
    [minutePinPath fill];
    [outerColor setStroke];
    minutePinPath.lineWidth = 0.5;
    [minutePinPath stroke];

    CGContextRestoreGState(context);


    //// secondPin Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 250, 250);
    CGContextRotateCTM(context, -secondCalc * M_PI/180);

    UIBezierPath* secondPinPath = [UIBezierPath bezierPath];
    [secondPinPath moveToPoint: CGPointMake(1, -238)];
    [secondPinPath addCurveToPoint: CGPointMake(4.79, -8.78) controlPoint1: CGPointMake(1, -238) controlPoint2: CGPointMake(3.96, -43.69)];
    [secondPinPath addCurveToPoint: CGPointMake(10, 0) controlPoint1: CGPointMake(7.89, -7.08) controlPoint2: CGPointMake(10, -3.79)];
    [secondPinPath addCurveToPoint: CGPointMake(0, 10) controlPoint1: CGPointMake(10, 5.52) controlPoint2: CGPointMake(5.52, 10)];
    [secondPinPath addCurveToPoint: CGPointMake(-10, 0) controlPoint1: CGPointMake(-5.52, 10) controlPoint2: CGPointMake(-10, 5.52)];
    [secondPinPath addCurveToPoint: CGPointMake(-4.79, -8.78) controlPoint1: CGPointMake(-10, -3.79) controlPoint2: CGPointMake(-7.89, -7.08)];
    [secondPinPath addCurveToPoint: CGPointMake(-1, -210) controlPoint1: CGPointMake(-3.84, -48.56) controlPoint2: CGPointMake(-1, -210)];
    [secondPinPath addCurveToPoint: CGPointMake(-0.98, -238.21) controlPoint1: CGPointMake(-1, -210.07) controlPoint2: CGPointMake(-0.99, -238.14)];
    [secondPinPath addCurveToPoint: CGPointMake(0, -239) controlPoint1: CGPointMake(-0.88, -238.66) controlPoint2: CGPointMake(-0.48, -239)];
    [secondPinPath addCurveToPoint: CGPointMake(1, -238) controlPoint1: CGPointMake(0.55, -239) controlPoint2: CGPointMake(1, -238.55)];
    [secondPinPath closePath];
    [secondColor setFill];
    [secondPinPath fill];

    CGContextRestoreGState(context);


    //// Oval Drawing
    UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(240, 240, 20, 20)];
    [UIColor.blackColor setFill];
    [ovalPath fill];
    
    CGContextRestoreGState(context);

}

+ (void)drawNormalClockFaceWithMinuteValue: (CGFloat)minuteValue hourValue: (CGFloat)hourValue isHourDot: (BOOL)isHourDot
{
    [ClockKit drawNormalClockFaceWithFrame: CGRectMake(0, 0, 500, 500) resizing: ClockKitResizingBehaviorStretch minuteValue: minuteValue hourValue: hourValue isHourDot: isHourDot];
}

+ (void)drawNormalClockFaceWithFrame: (CGRect)targetFrame resizing: (ClockKitResizingBehavior)resizing minuteValue: (CGFloat)minuteValue hourValue: (CGFloat)hourValue isHourDot: (BOOL)isHourDot
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Resize to Target Frame
    CGContextSaveGState(context);
    CGRect resizedFrame = ClockKitResizingBehaviorApply(resizing, CGRectMake(0, 0, 500, 500), targetFrame);
    CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
    CGContextScaleCTM(context, resizedFrame.size.width / 500, resizedFrame.size.height / 500);


    //// Color Declarations
    UIColor* dotColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];

    //// Variable Declarations
    CGFloat minuteCalc = -minuteValue * 6;
    CGFloat hourCalc = -hourValue * 30;
    BOOL isMinuteDot = !isHourDot;

    if (isHourDot)
    {
        //// hourDot Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 250, 250);
        CGContextRotateCTM(context, -hourCalc * M_PI/180);

        UIBezierPath* hourDotPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-2, -249, 4, 12) cornerRadius: 2];
        [dotColor setFill];
        [hourDotPath fill];

        CGContextRestoreGState(context);
    }


    if (isMinuteDot)
    {
        //// minuteDot Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 250, 250);
        CGContextRotateCTM(context, -minuteCalc * M_PI/180);

        UIBezierPath* minuteDotPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-2, -249, 4, 4) cornerRadius: 2];
        [dotColor setFill];
        [minuteDotPath fill];

        CGContextRestoreGState(context);
    }
    
    CGContextRestoreGState(context);

}

@end



CGRect ClockKitResizingBehaviorApply(ClockKitResizingBehavior behavior, CGRect rect, CGRect target)
{
    if (CGRectEqualToRect(rect, target) || CGRectEqualToRect(target, CGRectZero))
        return rect;

    CGSize scales = CGSizeZero;
    scales.width = ABS(target.size.width / rect.size.width);
    scales.height = ABS(target.size.height / rect.size.height);

    switch (behavior)
    {
        case ClockKitResizingBehaviorAspectFit:
        {
            scales.width = MIN(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case ClockKitResizingBehaviorAspectFill:
        {
            scales.width = MAX(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case ClockKitResizingBehaviorStretch:
            break;
        case ClockKitResizingBehaviorCenter:
        {
            scales.width = 1;
            scales.height = 1;
            break;
        }
    }

    CGRect result = CGRectStandardize(rect);
    result.size.width *= scales.width;
    result.size.height *= scales.height;
    result.origin.x = target.origin.x + (target.size.width - result.size.width) / 2;
    result.origin.y = target.origin.y + (target.size.height - result.size.height) / 2;
    return result;
}
