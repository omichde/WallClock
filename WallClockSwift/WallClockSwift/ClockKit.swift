//
//  ClockKit.swift
//  WallClock
//
//  Created by Oliver on 05.08.17.
//  Copyright Â© 2017 CompanyName. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class ClockKit : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawNormalClock(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 500, height: 500), resizing: ResizingBehavior = .aspectFit, secondValue: CGFloat = 0, minuteValue: CGFloat = 60, hourValue: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 500, height: 500), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 500, y: resizedFrame.height / 500)


        //// Color Declarations
        let hourColor = UIColor(red: 0.198, green: 0.198, blue: 0.198, alpha: 1.000)
        var hourColorRedComponent: CGFloat = 1
        var hourColorGreenComponent: CGFloat = 1
        var hourColorBlueComponent: CGFloat = 1
        hourColor.getRed(&hourColorRedComponent, green: &hourColorGreenComponent, blue: &hourColorBlueComponent, alpha: nil)

        let hourColorHigh = UIColor(red: (hourColorRedComponent * 0.3 + 0.7), green: (hourColorGreenComponent * 0.3 + 0.7), blue: (hourColorBlueComponent * 0.3 + 0.7), alpha: (hourColor.cgColor.alpha * 0.3 + 0.7))
        let minuteColor = UIColor(red: 0.472, green: 0.472, blue: 0.472, alpha: 1.000)
        var minuteColorRedComponent: CGFloat = 1
        var minuteColorGreenComponent: CGFloat = 1
        var minuteColorBlueComponent: CGFloat = 1
        minuteColor.getRed(&minuteColorRedComponent, green: &minuteColorGreenComponent, blue: &minuteColorBlueComponent, alpha: nil)

        let minuteColorHigh = UIColor(red: (minuteColorRedComponent * 0.3 + 0.7), green: (minuteColorGreenComponent * 0.3 + 0.7), blue: (minuteColorBlueComponent * 0.3 + 0.7), alpha: (minuteColor.cgColor.alpha * 0.3 + 0.7))
        let secondColor = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)
        var secondColorRedComponent: CGFloat = 1
        var secondColorGreenComponent: CGFloat = 1
        var secondColorBlueComponent: CGFloat = 1
        secondColor.getRed(&secondColorRedComponent, green: &secondColorGreenComponent, blue: &secondColorBlueComponent, alpha: nil)

        let secondColorHigh = UIColor(red: (secondColorRedComponent * 0.3 + 0.7), green: (secondColorGreenComponent * 0.3 + 0.7), blue: (secondColorBlueComponent * 0.3 + 0.7), alpha: (secondColor.cgColor.alpha * 0.3 + 0.7))
        let dotColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        var dotColorRedComponent: CGFloat = 1
        var dotColorGreenComponent: CGFloat = 1
        var dotColorBlueComponent: CGFloat = 1
        dotColor.getRed(&dotColorRedComponent, green: &dotColorGreenComponent, blue: &dotColorBlueComponent, alpha: nil)

        let dotColorHigh = UIColor(red: (dotColorRedComponent * 0.7 + 0.3), green: (dotColorGreenComponent * 0.7 + 0.3), blue: (dotColorBlueComponent * 0.7 + 0.3), alpha: (dotColor.cgColor.alpha * 0.7 + 0.3))

        //// Variable Declarations
        let secondCalc: CGFloat = -secondValue * 6
        let minuteCalc: CGFloat = -minuteValue * 6
        let hourCalc: CGFloat = -hourValue * 30

        //// hourPin Drawing
        context.saveGState()
        context.translateBy(x: 250, y: 250)
        context.rotate(by: -hourCalc * CGFloat.pi/180)

        let hourPinPath = UIBezierPath(roundedRect: CGRect(x: -7, y: -170, width: 14, height: 177), cornerRadius: 5)
        hourColor.setFill()
        hourPinPath.fill()
        hourColorHigh.setStroke()
        hourPinPath.lineWidth = 0.5
        hourPinPath.stroke()

        context.restoreGState()


        //// minutePin Drawing
        context.saveGState()
        context.translateBy(x: 250, y: 250)
        context.rotate(by: -minuteCalc * CGFloat.pi/180)

        let minutePinPath = UIBezierPath(roundedRect: CGRect(x: -3, y: -250, width: 6, height: 253), cornerRadius: 3)
        minuteColor.setFill()
        minutePinPath.fill()
        minuteColorHigh.setStroke()
        minutePinPath.lineWidth = 0.5
        minutePinPath.stroke()

        context.restoreGState()


        //// secondPin Drawing
        context.saveGState()
        context.translateBy(x: 250, y: 250)
        context.rotate(by: -secondCalc * CGFloat.pi/180)

        let secondPinPath = UIBezierPath()
        secondPinPath.move(to: CGPoint(x: 1, y: -238))
        secondPinPath.addCurve(to: CGPoint(x: 5, y: 0), controlPoint1: CGPoint(x: 1, y: -238), controlPoint2: CGPoint(x: 4.17, y: -34.91))
        secondPinPath.addCurve(to: CGPoint(x: 0, y: 5), controlPoint1: CGPoint(x: 5, y: 0), controlPoint2: CGPoint(x: 5.52, y: 5))
        secondPinPath.addCurve(to: CGPoint(x: -5, y: 0), controlPoint1: CGPoint(x: -5.52, y: 5), controlPoint2: CGPoint(x: -5, y: 0))
        secondPinPath.addCurve(to: CGPoint(x: -1, y: -210), controlPoint1: CGPoint(x: -4.05, y: -39.78), controlPoint2: CGPoint(x: -1, y: -210))
        secondPinPath.addCurve(to: CGPoint(x: -0.98, y: -238.21), controlPoint1: CGPoint(x: -1, y: -210.07), controlPoint2: CGPoint(x: -0.99, y: -238.14))
        secondPinPath.addCurve(to: CGPoint(x: 0, y: -239), controlPoint1: CGPoint(x: -0.88, y: -238.66), controlPoint2: CGPoint(x: -0.48, y: -239))
        secondPinPath.addCurve(to: CGPoint(x: 1, y: -238), controlPoint1: CGPoint(x: 0.55, y: -239), controlPoint2: CGPoint(x: 1, y: -238.55))
        secondPinPath.close()
        secondColor.setFill()
        secondPinPath.fill()
        secondColorHigh.setStroke()
        secondPinPath.lineWidth = 0.5
        secondPinPath.stroke()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 240, y: 240, width: 20, height: 20))
        UIColor.black.setFill()
        ovalPath.fill()
        dotColorHigh.setStroke()
        ovalPath.lineWidth = 0.5
        ovalPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNormalClockFace(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 500, height: 500), resizing: ResizingBehavior = .aspectFit, minuteValue: CGFloat = 60, hourValue: CGFloat = 0, isHourDot: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 500, height: 500), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 500, y: resizedFrame.height / 500)


        //// Color Declarations
        let dotColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Variable Declarations
        let minuteCalc: CGFloat = -minuteValue * 6
        let hourCalc: CGFloat = -hourValue * 30
        let isMinuteDot = !isHourDot

        if (isHourDot) {
            //// hourDot Drawing
            context.saveGState()
            context.translateBy(x: 250, y: 250)
            context.rotate(by: -hourCalc * CGFloat.pi/180)

            let hourDotPath = UIBezierPath(roundedRect: CGRect(x: -2, y: -249, width: 4, height: 12), cornerRadius: 2)
            dotColor.setFill()
            hourDotPath.fill()

            context.restoreGState()
        }


        if (isMinuteDot) {
            //// minuteDot Drawing
            context.saveGState()
            context.translateBy(x: 250, y: 250)
            context.rotate(by: -minuteCalc * CGFloat.pi/180)

            let minuteDotPath = UIBezierPath(roundedRect: CGRect(x: -2, y: -249, width: 4, height: 4), cornerRadius: 2)
            dotColor.setFill()
            minuteDotPath.fill()

            context.restoreGState()
        }
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLEDClock(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 180), resizing: ResizingBehavior = .aspectFit, led0: Bool = true, led1: Bool = true, led2: Bool = true, led3: Bool = true, led4: Bool = true, led5: Bool = true, led6: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 180), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 180)


        //// Color Declarations
        let barColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        if (led3) {
            //// Bezier Drawing
            let bezierPath = UIBezierPath()
            bezierPath.move(to: CGPoint(x: 10, y: 90))
            bezierPath.addLine(to: CGPoint(x: 19.5, y: 80))
            bezierPath.addLine(to: CGPoint(x: 80, y: 80))
            bezierPath.addLine(to: CGPoint(x: 90, y: 90))
            bezierPath.addLine(to: CGPoint(x: 80, y: 100))
            bezierPath.addLine(to: CGPoint(x: 20, y: 100))
            bezierPath.addLine(to: CGPoint(x: 10, y: 90))
            bezierPath.close()
            barColor.setFill()
            bezierPath.fill()
            UIColor.white.setStroke()
            bezierPath.lineWidth = 1
            bezierPath.stroke()
        }


        if (led1) {
            //// Bezier 9 Drawing
            let bezier9Path = UIBezierPath()
            bezier9Path.move(to: CGPoint(x: 2.93, y: 2.93))
            bezier9Path.addCurve(to: CGPoint(x: 20, y: 20), controlPoint1: CGPoint(x: 8.48, y: 8.48), controlPoint2: CGPoint(x: 20, y: 20))
            bezier9Path.addLine(to: CGPoint(x: 20, y: 80))
            bezier9Path.addLine(to: CGPoint(x: 10, y: 90))
            bezier9Path.addLine(to: CGPoint(x: 0, y: 80.5))
            bezier9Path.addCurve(to: CGPoint(x: 0, y: 10), controlPoint1: CGPoint(x: 0, y: 80.5), controlPoint2: CGPoint(x: 0, y: 31.56))
            bezier9Path.addCurve(to: CGPoint(x: 2.93, y: 2.93), controlPoint1: CGPoint(x: 0, y: 7.24), controlPoint2: CGPoint(x: 1.12, y: 4.74))
            bezier9Path.close()
            barColor.setFill()
            bezier9Path.fill()
            UIColor.white.setStroke()
            bezier9Path.lineWidth = 1
            bezier9Path.stroke()
        }


        if (led0) {
            //// Bezier 8 Drawing
            let bezier8Path = UIBezierPath()
            bezier8Path.move(to: CGPoint(x: 97.07, y: 2.93))
            bezier8Path.addCurve(to: CGPoint(x: 80, y: 20), controlPoint1: CGPoint(x: 91.52, y: 8.48), controlPoint2: CGPoint(x: 80, y: 20))
            bezier8Path.addLine(to: CGPoint(x: 20, y: 20))
            bezier8Path.addCurve(to: CGPoint(x: 2.93, y: 2.93), controlPoint1: CGPoint(x: 20, y: 20), controlPoint2: CGPoint(x: 8.48, y: 8.48))
            bezier8Path.addCurve(to: CGPoint(x: 9.75, y: 0), controlPoint1: CGPoint(x: 4.68, y: 1.17), controlPoint2: CGPoint(x: 7.09, y: 0.07))
            bezier8Path.addLine(to: CGPoint(x: 10, y: 0))
            bezier8Path.addLine(to: CGPoint(x: 90, y: 0))
            bezier8Path.addCurve(to: CGPoint(x: 97.07, y: 2.93), controlPoint1: CGPoint(x: 92.76, y: -0), controlPoint2: CGPoint(x: 95.26, y: 1.12))
            bezier8Path.close()
            barColor.setFill()
            bezier8Path.fill()
            UIColor.white.setStroke()
            bezier8Path.lineWidth = 1
            bezier8Path.stroke()
        }


        if (led2) {
            //// Bezier 2 Drawing
            let bezier2Path = UIBezierPath()
            bezier2Path.move(to: CGPoint(x: 97.07, y: 2.93))
            bezier2Path.addCurve(to: CGPoint(x: 80, y: 20), controlPoint1: CGPoint(x: 91.52, y: 8.48), controlPoint2: CGPoint(x: 80, y: 20))
            bezier2Path.addLine(to: CGPoint(x: 80, y: 80))
            bezier2Path.addLine(to: CGPoint(x: 90, y: 90))
            bezier2Path.addLine(to: CGPoint(x: 100, y: 80.5))
            bezier2Path.addCurve(to: CGPoint(x: 100, y: 10), controlPoint1: CGPoint(x: 100, y: 80.5), controlPoint2: CGPoint(x: 100, y: 31.56))
            bezier2Path.addCurve(to: CGPoint(x: 97.07, y: 2.93), controlPoint1: CGPoint(x: 100, y: 7.24), controlPoint2: CGPoint(x: 98.88, y: 4.74))
            bezier2Path.close()
            barColor.setFill()
            bezier2Path.fill()
            UIColor.white.setStroke()
            bezier2Path.lineWidth = 1
            bezier2Path.stroke()
        }


        if (led4) {
            //// Bezier 3 Drawing
            let bezier3Path = UIBezierPath()
            bezier3Path.move(to: CGPoint(x: 2.93, y: 177.07))
            bezier3Path.addCurve(to: CGPoint(x: 20, y: 160), controlPoint1: CGPoint(x: 8.48, y: 171.52), controlPoint2: CGPoint(x: 20, y: 160))
            bezier3Path.addLine(to: CGPoint(x: 20, y: 100))
            bezier3Path.addLine(to: CGPoint(x: 10, y: 90))
            bezier3Path.addLine(to: CGPoint(x: 0, y: 99.5))
            bezier3Path.addCurve(to: CGPoint(x: 0, y: 170), controlPoint1: CGPoint(x: 0, y: 99.5), controlPoint2: CGPoint(x: 0, y: 148.44))
            bezier3Path.addCurve(to: CGPoint(x: 2.93, y: 177.07), controlPoint1: CGPoint(x: 0, y: 172.76), controlPoint2: CGPoint(x: 1.12, y: 175.26))
            bezier3Path.close()
            barColor.setFill()
            bezier3Path.fill()
            UIColor.white.setStroke()
            bezier3Path.lineWidth = 1
            bezier3Path.stroke()
        }


        if (led6) {
            //// Bezier 4 Drawing
            let bezier4Path = UIBezierPath()
            bezier4Path.move(to: CGPoint(x: 97.07, y: 177.07))
            bezier4Path.addCurve(to: CGPoint(x: 80, y: 160), controlPoint1: CGPoint(x: 91.52, y: 171.52), controlPoint2: CGPoint(x: 80, y: 160))
            bezier4Path.addLine(to: CGPoint(x: 20, y: 160))
            bezier4Path.addCurve(to: CGPoint(x: 2.93, y: 177.07), controlPoint1: CGPoint(x: 20, y: 160), controlPoint2: CGPoint(x: 8.48, y: 171.52))
            bezier4Path.addCurve(to: CGPoint(x: 9.75, y: 180), controlPoint1: CGPoint(x: 4.68, y: 178.83), controlPoint2: CGPoint(x: 7.09, y: 179.93))
            bezier4Path.addLine(to: CGPoint(x: 10, y: 180))
            bezier4Path.addLine(to: CGPoint(x: 90, y: 180))
            bezier4Path.addCurve(to: CGPoint(x: 97.07, y: 177.07), controlPoint1: CGPoint(x: 92.76, y: 180), controlPoint2: CGPoint(x: 95.26, y: 178.88))
            bezier4Path.close()
            barColor.setFill()
            bezier4Path.fill()
            UIColor.white.setStroke()
            bezier4Path.lineWidth = 1
            bezier4Path.stroke()
        }


        if (led5) {
            //// Bezier 5 Drawing
            let bezier5Path = UIBezierPath()
            bezier5Path.move(to: CGPoint(x: 97.07, y: 177.07))
            bezier5Path.addCurve(to: CGPoint(x: 80, y: 160), controlPoint1: CGPoint(x: 91.52, y: 171.52), controlPoint2: CGPoint(x: 80, y: 160))
            bezier5Path.addLine(to: CGPoint(x: 80, y: 100))
            bezier5Path.addLine(to: CGPoint(x: 90, y: 90))
            bezier5Path.addLine(to: CGPoint(x: 100, y: 99.5))
            bezier5Path.addCurve(to: CGPoint(x: 100, y: 170), controlPoint1: CGPoint(x: 100, y: 99.5), controlPoint2: CGPoint(x: 100, y: 148.44))
            bezier5Path.addCurve(to: CGPoint(x: 97.07, y: 177.07), controlPoint1: CGPoint(x: 100, y: 172.76), controlPoint2: CGPoint(x: 98.88, y: 175.26))
            bezier5Path.close()
            barColor.setFill()
            bezier5Path.fill()
            UIColor.white.setStroke()
            bezier5Path.lineWidth = 1
            bezier5Path.stroke()
        }
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLEDDot(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 180), resizing: ResizingBehavior = .aspectFit, secondValue: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 180), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 180)


        //// Color Declarations
        let dotColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Variable Declarations
        let isEvenSecond = fmod(secondValue, 2) == 0 ? dotColor : UIColor(red: 0, green: 0, blue: 0, alpha: 0)

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 40.5, y: 109.5, width: 20, height: 20))
        isEvenSecond.setFill()
        rectanglePath.fill()
        UIColor.white.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 40.5, y: 49.5, width: 20, height: 20))
        isEvenSecond.setFill()
        rectangle2Path.fill()
        UIColor.white.setStroke()
        rectangle2Path.lineWidth = 1
        rectangle2Path.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawClockSlice(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 500, height: 500), resizing: ResizingBehavior = .aspectFit, sliceColor: UIColor = UIColor(red: 0.348, green: 0.800, blue: 0.320, alpha: 1.000), sliceStartValue: CGFloat = 4, sliceEndValue: CGFloat = 15) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 500, height: 500), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 500, y: resizedFrame.height / 500)



        //// Variable Declarations
        let sliceStartAngle: CGFloat = -sliceStartValue * 6 + 90
        let sliceEndAngle: CGFloat = -sliceEndValue * 6 + 90

        //// Oval Drawing
        let ovalRect = CGRect(x: 0, y: 0, width: 500, height: 500)
        let ovalPath = UIBezierPath()
        ovalPath.addArc(withCenter: CGPoint(x: ovalRect.midX, y: ovalRect.midY), radius: ovalRect.width / 2, startAngle: -sliceStartAngle * CGFloat.pi/180, endAngle: -sliceEndAngle * CGFloat.pi/180, clockwise: true)
        ovalPath.addLine(to: CGPoint(x: ovalRect.midX, y: ovalRect.midY))
        ovalPath.close()

        sliceColor.setFill()
        ovalPath.fill()
        
        context.restoreGState()

    }




    @objc(ClockKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
